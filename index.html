<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Very Easy Nonogram</title>
    <style>
        :root { 
            --cell-size: 28px; 
            --bg-color: #f8f9fa; 
            --grid-border: #222; 
            --clue-bg: #1a365d; 
            --clue-text: #ffffff;
        }
        
        html, body { height: 100%; margin: 0; padding: 0; }
        body { 
            font-family: 'Segoe UI', system-ui, sans-serif; 
            background: var(--bg-color); 
            display: flex; 
            flex-direction: column; 
            justify-content: center; 
            align-items: center;     
            user-select: none; 
        }
        
        .game-wrapper { 
            display: grid; 
            grid-template-columns: auto auto; 
            background: white; 
            padding: 25px; 
            border-radius: 12px; 
            box-shadow: 0 10px 30px rgba(0,0,0,0.1); 
        }
        
        #grid { 
            display: grid; 
            border: 3px solid var(--grid-border); 
            background-color: white;
            gap: 0px; 
            transition: border-color 1s ease;
        }

        body.won #grid { border-color: transparent; }

        .cell { 
            width: var(--cell-size); 
            height: var(--cell-size); 
            box-shadow: inset 0 0 0 0.5px #ccc;
            border: none;
            cursor: pointer; 
            background: white; 
            box-sizing: border-box; 
            position: relative;
            transition: box-shadow 1s ease, border-color 1s ease;
        }
        
        body.won .cell { box-shadow: none !important; border-color: transparent !important; }

        .cell.v-divider { 
            border-right: 3px solid var(--grid-border) !important;
            z-index: 10; 
        }
        .cell.h-divider { 
            border-bottom: 3px solid var(--grid-border) !important;
            z-index: 10; 
        }

        .cell.filled { background: #222 !important; box-shadow: none; }
        
        .cell.marked, .cell.hint { position: relative; background: white; }
        .cell.marked::after, .cell.hint::after { 
            content: '×'; position: absolute; color: #1a365d; 
            font-size: 22px; top: 50%; left: 50%; 
            transform: translate(-50%, -50%); font-weight: bold; 
            z-index: 15;
            transition: opacity 1s ease;
        }

        body.won .cell::after { opacity: 0; }

        .cell.hint { background: #fdfdfd; cursor: default; }

        .clue-number { 
            display: flex; align-items: center; justify-content: center;
            background: var(--clue-bg); color: var(--clue-text);
            min-width: 22px; height: 22px; border-radius: 4px;
            margin: 1.5px; font-size: 12px; font-weight: bold; 
            transition: opacity 0.3s ease;
        }
        .clue-number.completed { opacity: 0.15; }

        .clues-row { display: flex; flex-direction: column; justify-content: space-around; padding-right: 15px; text-align: right; font-weight: bold; }
        .clues-col { display: flex; justify-content: space-around; padding-bottom: 15px; font-weight: bold; align-items: flex-end; }
        .clue-group { height: var(--cell-size); display: flex; align-items: center; justify-content: flex-end; }
        .col-group { width: var(--cell-size); display: flex; flex-direction: column; align-items: center; line-height: 1.1; }

        .controls { margin-top: 30px; gap: 15px; display: flex; align-items: center; }
        button { padding: 12px 25px; border: none; border-radius: 6px; cursor: pointer; font-weight: 700; font-size: 14px; text-transform: uppercase; transition: 0.2s; }
        .btn-reset { background: #95a5a6; color: white; }
        .btn-undo { background: #e67e22; color: white; }
    </style>
</head>
<body>

    <div class="game-wrapper">
        <div id="spacer"></div>
        <div id="col-clues" class="clues-col"></div>
        <div id="row-clues" class="clues-row"></div>
        <div id="grid"></div>
    </div>

    <div class="controls">
        <button class="btn-undo" id="undoBtn" onclick="undo()">Undo</button>
        <button class="btn-reset" onclick="resetGame()">Reset</button>
    </div>

    <script>
        const solution = [
            [0,1,1,0,0,0,1,0,1,0,1,1,0,1,0,0,0,1], [1,0,1,1,0,1,0,1,1,0,1,1,0,1,0,0,0,1],
            [1,1,1,0,0,1,1,1,0,1,0,1,0,0,0,0,0,1], [0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1],
            [0,0,1,1,0,1,0,1,1,0,1,0,0,0,0,0,0,1], [0,1,0,0,0,1,1,1,0,0,0,1,0,1,0,0,0,1],
            [1,1,1,0,0,1,1,1,1,1,1,1,0,1,1,0,0,1], [0,0,1,0,0,1,1,0,0,0,1,1,0,0,0,0,0,1],
            [1,0,0,1,1,0,1,0,1,0,1,1,0,1,1,0,0,1], [0,0,0,1,0,0,1,0,0,0,1,1,1,0,0,0,0,1],
            [1,1,0,0,0,1,1,1,1,1,1,1,1,0,1,0,0,1], [1,1,0,1,0,0,0,0,0,1,0,1,1,0,0,0,0,1],
            [1,0,0,0,0,0,1,1,0,1,0,1,1,0,0,0,0,1], [1,1,1,0,1,1,0,1,1,1,1,0,0,1,1,0,0,1],
            [1,0,0,1,1,1,0,1,0,0,0,1,1,0,0,0,0,1], [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1], [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];

        const size = 18;
        let isDragging = false, mode = null; 
        let history = [];

        function getSequence(arr) {
            const counts = [];
            let current = 0;
            arr.forEach(val => { if (val === 1) current++; else if (current > 0) { counts.push(current); current = 0; } });
            if (current > 0) counts.push(current);
            return (counts.length === 0) ? [0] : counts;
        }

        function autoFinishLine(cells, solLine) {
            const userPattern = cells.map(c => c.classList.contains('filled') ? 1 : 0);
            if (JSON.stringify(getSequence(userPattern)) === JSON.stringify(getSequence(solLine))) {
                cells.forEach(cell => {
                    if (!cell.classList.contains('filled') && !cell.classList.contains('marked') && !cell.classList.contains('hint')) {
                        cell.classList.add('marked');
                    }
                });
            }
        }

        function getStrategicHints() {
            let selected = [];
            const step = 7; 
            for (let i = 0; selected.length < 30 && i < size * size * 10; i += step) {
                let r = Math.floor((i % (size * size)) / size);
                let c = (i % (size * size)) % size;
                if (r < 15 && c < 15) {
                    if (solution[r][c] === 0) {
                        if (!selected.some(h => h.r === r && h.c === c)) {
                            selected.push({r, c});
                        }
                    }
                }
            }
            return selected;
        }

        let currentHints = getStrategicHints();

        function checkWin() {
            const isWon = Array.from(document.querySelectorAll('.cell')).every(c => (solution[c.dataset.r][c.dataset.c] === 1) === c.classList.contains('filled'));
            if (isWon) {
                document.body.classList.add('won');
            }
        }

        function updateClueState() {
            const checkLine = (cells, group, solLine) => {
                const spans = group.querySelectorAll('.clue-number');
                spans.forEach(s => s.classList.remove('completed'));
                const getIslands = (pattern) => {
                    let islands = [], inIsland = false, start = 0;
                    for(let i = 0; i <= pattern.length; i++) {
                        if(pattern[i] === 1 && !inIsland) { inIsland = true; start = i; }
                        else if((pattern[i] !== 1 || i === pattern.length) && inIsland) {
                            inIsland = false; islands.push({start, len: i - start});
                        }
                    }
                    return islands;
                };
                const userPattern = cells.map(c => c.classList.contains('filled') ? 1 : 0);
                const uIslands = getIslands(userPattern);
                const sSequence = getSequence(solLine);
                if (sSequence[0] === 0 && userPattern.every(v => v === 0)) {
                    spans.forEach(s => s.classList.add('completed'));
                    autoFinishLine(cells, solLine);
                    return;
                }
                const fMatch = new Array(sSequence.length).fill(-1);
                const bMatch = new Array(sSequence.length).fill(-1);
                let fIdx = 0;
                for (let c = 0; c < sSequence.length; c++) {
                    for (let i = fIdx; i < uIslands.length; i++) {
                        const ui = uIslands[i];
                        const spaceAfter = sSequence.slice(c + 1).reduce((s, v) => s + v + 1, 0);
                        if (ui.len === sSequence[c] && (size - (ui.start + ui.len)) >= spaceAfter) {
                            fMatch[c] = i; fIdx = i + 1; break;
                        }
                    }
                }
                let bIdx = uIslands.length - 1;
                for (let c = sSequence.length - 1; c >= 0; c--) {
                    for (let i = bIdx; i >= 0; i--) {
                        const ui = uIslands[i];
                        const spaceBefore = sSequence.slice(0, c).reduce((s, v) => s + v + 1, 0);
                        if (ui.len === sSequence[c] && ui.start >= spaceBefore) {
                            bMatch[c] = i; bIdx = i - 1; break;
                        }
                    }
                }
                for (let c = 0; c < sSequence.length; c++) {
                    if (fMatch[c] !== -1 && fMatch[c] === bMatch[c]) {
                        spans[c].classList.add('completed');
                    }
                }
                autoFinishLine(cells, solLine);
            };
            document.querySelectorAll('.clues-row .clue-group').forEach((g, r) => checkLine(Array.from(document.querySelectorAll(`.cell[data-r="${r}"]`)), g, solution[r]));
            document.querySelectorAll('.clues-col .col-group').forEach((g, c) => checkLine(Array.from(document.querySelectorAll(`.cell[data-c="${c}"]`)), g, solution.map(row => row[c])));
        }

        function applyAction(cell, record = true) {
            if (cell.classList.contains('hint') || document.body.classList.contains('won')) return;
            if (record) {
                const state = { r: cell.dataset.r, c: cell.dataset.c, filled: cell.classList.contains('filled'), marked: cell.classList.contains('marked') };
                if ((mode === 'fill' && !state.filled) || (mode === 'unfill' && state.filled) || (mode === 'mark' && !state.marked) || (mode === 'unmark' && state.marked)) {
                    history.push(state);
                }
            }
            if (mode === 'fill') { cell.classList.add('filled'); cell.classList.remove('marked'); }
            else if (mode === 'unfill') cell.classList.remove('filled');
            else if (mode === 'mark') { cell.classList.add('marked'); cell.classList.remove('filled'); }
            else if (mode === 'unmark') cell.classList.remove('marked');
            updateClueState();
            checkWin();
        }

        function undo() {
            if (history.length === 0 || document.body.classList.contains('won')) return;
            const last = history.pop();
            const cell = document.querySelector(`.cell[data-r="${last.r}"][data-c="${last.c}"]`);
            last.filled ? cell.classList.add('filled') : cell.classList.remove('filled');
            last.marked ? cell.classList.add('marked') : cell.classList.remove('marked');
            updateClueState();
        }

        function init() {
            const grid = document.getElementById('grid');
            grid.innerHTML = ''; document.getElementById('row-clues').innerHTML = ''; document.getElementById('col-clues').innerHTML = '';
            grid.style.gridTemplateColumns = `repeat(${size}, var(--cell-size))`;

            for (let c = 0; c < size; c++) {
                const div = document.createElement('div'); div.className = 'col-group';
                getSequence(solution.map(row => row[c])).forEach(count => {
                    const span = document.createElement('div'); span.className = 'clue-number'; span.innerText = count;
                    div.appendChild(span);
                });
                document.getElementById('col-clues').appendChild(div);
            }
            for (let r = 0; r < size; r++) {
                const div = document.createElement('div'); div.className = 'clue-group';
                getSequence(solution[r]).forEach(count => {
                    const span = document.createElement('div'); span.className = 'clue-number'; span.innerText = count;
                    div.appendChild(span);
                });
                document.getElementById('row-clues').appendChild(div);
                for (let c = 0; c < size; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.r = r; cell.dataset.c = c;
                    
                    if ((c + 1) % 3 === 0 && c !== size - 1) cell.classList.add('v-divider');
                    if ((r + 1) % 3 === 0 && r !== size - 1) cell.classList.add('h-divider');

                    if (currentHints.some(h => h.r === r && h.c === c)) cell.classList.add('hint');
                    cell.addEventListener('mousedown', (e) => {
                        isDragging = true;
                        if (e.button === 0) mode = cell.classList.contains('filled') ? 'unfill' : 'fill';
                        else if (e.button === 2) mode = cell.classList.contains('marked') ? 'unmark' : 'mark';
                        applyAction(cell);
                    });
                    cell.addEventListener('mouseenter', () => isDragging && applyAction(cell));
                    cell.addEventListener('contextmenu', e => e.preventDefault());
                    grid.appendChild(cell);
                }
            }
            updateClueState();
        }

        window.addEventListener('mouseup', () => { isDragging = false; mode = null; });
        function resetGame() {
            if(confirm("U muốn reset thiệt hẻ :((")) {
                location.reload();
            }
        }
        init();
    </script>
</body>
</html>